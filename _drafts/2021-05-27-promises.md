---
title: "Chapter 11: Promises and Async Functions - Promises" 
categories: ['Professional Javascript']
tags: ['frontend', 'javascript']
resource_path: /blog/assets/2021/05/27
---

# Promises

- [Promises](#promises)
  - [The Promises/A+ Specification](#the-promisesa-specification)
  - [Promise Basics](#promise-basics)
    - [The Paromise State Machine](#the-paromise-state-machine)
    - [Resolved Values, Rejection Reasons, and Utility of Promises](#resolved-values-rejection-reasons-and-utility-of-promises)
    - [Controlling Promise State with the Executor](#controlling-promise-state-with-the-executor)
    - [Promise Casting with `Promise.resolve()`](#promise-casting-with-promiseresolve)
    - [Promise Rejection with `Promise.reject()`](#promise-rejection-with-promisereject)
    - [Synchronous/Asynchronous Execution Duality](#synchronousasynchronous-execution-duality)
  - [Promise Instance Methods](#promise-instance-methods)
    - [Implementing the Thenable Interface](#implementing-the-thenable-interface)
    - [Promise.prototype.then()](#promiseprototypethen)
    - [Promise.prototype.catch()](#promiseprototypecatch)
    - [Promise.prototype.finally()](#promiseprototypefinally)
    - [Non-Reentrant Promise Methods](#non-reentrant-promise-methods)
    - [Sibling Handler Order of Execution](#sibling-handler-order-of-execution)
    - [Resolved Value and Rejected Reason Passing](#resolved-value-and-rejected-reason-passing)
    - [Rejecting Promises and Rejection Error Handling](#rejecting-promises-and-rejection-error-handling)
  - [Promise Chaining and Composition](#promise-chaining-and-composition)
    - [Promise Chaining](#promise-chaining)
    - [Promise Graphs](#promise-graphs)
    - [Parallel Promise Composition with Promise.all() and Promise.race()](#parallel-promise-composition-with-promiseall-and-promiserace)
    - [Serial Promise Composition](#serial-promise-composition)
  - [Promise Extensions](#promise-extensions)
    - [Promise Canceling](#promise-canceling)
    - [Promise Progress Notifications](#promise-progress-notifications)


A “promise” is a surrogate entity that acts as a stand-in for a result that does not yet exist.

---

## The Promises/A+ Specification

Early forms of promises appeared in jQuery and Dojo’s Deferred API. In 2010, growing popularity led to the Promises/A specification inside the ComonJS project. Third-party JavaScript promise libararies continued to gain adoption, yet each implementation was slightly different. To address the rifts in the promise space, in 2012 the Promises/A+ organization forked the CommonJS "Promises/A" proposal and created the eponymous Promises/A+ Promise Specification (https://promisesaplus.com/).

This specification would eventually govern how promises were implemented in the ECMAScript 6 specification.

Multiple browser APIs such as fetch() and the battery API use it exclusively.

---

## Promise Basics

The `Promise` reference type can be instantiated with the `new` operator. Doing so requires passing an *executor* function parameter.

```js
let executor = () => {}
let p = new Promise(executor);
setTimeout(console.log, 0, p);  // Promise <pending>
```

In this section, we do not use the `then` method, we only care about the internal state of promise.

### The Paromise State Machine

![state machine](./promises.png)

1. State machine:  
    A promise is a stateful object that can exist in one of three state:
    1. *Pending*
    2. *Fulfilled* (sometimes also refered to as *resolved*)
    3. *Rejected*
    A *pending* state is the initial state a promise begins in. From a *pending* state, a promise can become *settled* by transitioning to a *fulfilled* state to indicate success, or a *rejected* state to indicate failure.

2. This transition to a settled state is **irreversible**.

3. It is **not guaranteed that a promise will ever leave the *pending* state**. 

4. The state of a promise is private and **cannot be directly inspected** in JavaScript. The reason for this is primarily to prevent synchronous programmatic handling of a promise object based on its state when it is read.

5. Furthermore, the state of a promise **cannot be mutated** by external JavaScript. So that you cannot control the state manually.

6. Why we cannot directly inspect and mutate the state of a promise?  
     The promise intentionally encapsulates a block of asynchronous behavior, and external code performing synchronous definition of its state would be antithetical to its purpose.

总结: 不保证执行, 一旦执行不可逆转, 不能读取状态, 不能修改状态

### Resolved Values, Rejection Reasons, and Utility of Promises

1. Abstractly represent a block of asynchronous execution.  
    The state of the promise is indicative of whether or not the promise has yet to complete execution.

2. Every promise that transitions to a fulfilled state has a private internal *value*. Similarly, every promise that transitions to a rejected state has a private internal *reason*. 

3. Asynchronous code (`resolve` and `reject`) that is scheduled to execute after a promise reaches a certain settled state is always provided with the *value* (`resolve`) or *reason* (`reject`).

### Controlling Promise State with the Executor

1. Because the state of a promise is private, it can only be manipulated internally. This internal manipulation is performed inside the promise’s executor function. 

2. The executor function has two primary duties
    1. initializing the asynchronous behavior of the promise
    2. controlling any eventual state transition.

3. Control of the state transition is accomplished by invoking one of its two function parameters, typically named `resolve` and `reject`. Invoking resolve will change the state to *fulfilled*; invoking `reject` will change the state to *rejected*. Invoking `rejected()` will also throw an error (this error behavior is covered more later).
  ```js
  let p1 = new Promise((resolve, reject) => resolve());
  setTimeout(console.log, 0, p1); // Promise <resolved>
  
  let p2 = new Promise((resolve, reject) => reject());
  setTimeout(console.log, 0, p2); // Promise <rejected>
  // Uncaught error (in promise)
  ```

4. The executor function will execute **synchronously**, as it acts as the **initializer** for the promise. 

5. You can avoid promises getting stuck in a pending state by adding timed exit behavior. 
    ```js
    let p = new Promise((resolve, reject) => {
      setTimeout(reject, 10000);
    }0;
    ```

### Promise Casting with `Promise.resolve()`

1. It is possible to instantiate a promise in the "*resolved*" state by invoking the `Promise.resolve()` static method without executor function. The following two promise instantiations are effectively equivalent:

```js
let p1 = new Promise((resolve, reject) => resolve())
let p2 = Promise.resolve();
```

2. This effectively allows you to "cast" any value into a promise:
    ```js
    setTimeout(console.log, 0, Promise.resolve()); // Promise <resolved>: undefined
    setTimeout(console.log, 0, Promise.resolve(3)); // Promise <resolved>: 3
    // Additional arguments are ignored
    setTimeout(console.log, 0, Promise.resolve(4, 5, 6));
    // Promise <resolved>: 4
    ```

3. Perhaps the most important aspect of this static method is its ability to act as a **passthrough** when the argument is already a promise. As a result, `Promise.resolve()` is an idempotent method. This idempotence will respect the state of the promise passsed to it:
    ```js
    let p = new Promise(() => {}); 
    
    setTimeout(console.log, 0, p);// Promise <pending>
    setTimeout(console.log, 0, Promise.resolve(p)); // Promise <pending>

    setTimeout(console.log, 0, p === Promise.resolve(p)); // true
    ```

4. Beware that this static method will happily wrap **any non-promise, including an error object**, as a resolved promise, which might lead to unintended behavior:
    ```js
    let p = Promise.resolve(new Error('foo'));

    setTimeout(console.log, 0, p); // Promise <resolved>: Error: foo
    ```

### Promise Rejection with `Promise.reject()`

1. Similar in concept to `Promise.resolve()`, `Promise.reject()` instantiates a rejected promise and throws an asynchronous error (which will not be caught by try/catch and can only be caught by a rejection handler). 

2. The following two promise instantiations are effectively equivalent:
    ```js
    let p1 = new Promise((resolve, reject) => reject());
    let p2 = Promise.reject();
    ```

3. Importantly, Promise.reject() does not mirror the behavior of `Promise.resolve()` with respect to idempotence. If passed a promise object, it will happily use that promise as the ‘reason’ field of the rejected promise:
    ```js
    setTimeout(console.log, 0, Promise.reject(Promise.resolve())); // Promise <rejected>: Promise <resolved>
    ```

### Synchronous/Asynchronous Execution Duality

```js
try {
  throw new Error("foo");
} catch (e) {
  console.log(e); // Error: foo
}
try {
  Promise.reject(new Error("bar"));
} catch (e) {
  console.log(e);
}
// Uncaught (in promise) Error: bar
```

---

## Promise Instance Methods

### Implementing the Thenable Interface

### Promise.prototype.then()

### Promise.prototype.catch()

### Promise.prototype.finally()

### Non-Reentrant Promise Methods

### Sibling Handler Order of Execution

### Resolved Value and Rejected Reason Passing

### Rejecting Promises and Rejection Error Handling

---

## Promise Chaining and Composition

### Promise Chaining

### Promise Graphs

### Parallel Promise Composition with Promise.all() and Promise.race()

### Serial Promise Composition

---

## Promise Extensions

### Promise Canceling

### Promise Progress Notifications

---

Reference:

- Professional JavaScript for Web Developers 4th Edition
