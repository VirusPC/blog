---
title: 二值化
categories: ['图像处理']
tags: [‘二值化’, 'binarize']
resource_path: /blog/assets/2020/06/05/binarize
---

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>

二值化
===

灰度图每个像素点的灰度都在0到255之间，二值化就是让每个像素点的值只能为0或255，使得图像呈现出明显的黑白对比效果。二值化进一步突出了图像的特征，缩减了图像的数据量，使得图像的进一步处理更为容易。二值化的一般思路是设置一个阈值，然后对图片的每个像素点进行判断：若灰度值大于阈值，则置灰度值为255；若灰度值小于阈值，则置灰度值为0。根据阈值的设置，可以大体分为[固定阈值二值化](#固定阈值二值化)和自适应阈值二值化两种。其中自适应阈值二值化有[OSTU二值化](#OSTU二值化)和[Kittle二值化](#Kittler二值化)等。

固定阈值二值化
---
选择一个固定的数值作为阈值。  
然而，在实际应用中，由于两种情况的出现，我们很难以找到一个通用的阈值：图像前景和图像背景的灰度值都很大或图像前景和图像背景的灰度值都很小。

OSTU二值化
---
OSTU算法也被称为大津法、最大类间方差法，它把图像所有的像素点按灰度值分成大于阈值和小于阈值两类，即分成前景和背景两个部分，然后计算两个类间的“类间方差”。类间方差越大，二值化效果就越好。  

记图像前景的像素点数量占全部像素点数量比例为$$ w_0 $$，前景的平均灰度为$$ \mu_0 $$；图像背景的像素点数量占全部像素点数量的比例为$$ w_1 $$，背景像素点的平均灰度值为$$ \mu_1 $$；所有像素点灰度值的平均值为$$ \mu $$，类间方差为g，我们可以得到如下的公式：  
$$
\mu = w_0 * \mu_0 + w_1 * \mu_1 \tag{1}
$$  
$$
g = w_0*(\mu_0-\mu)^2+w_1*(\mu_1-\mu)^2 \tag{2}
$$  
将公式（1）代入公式（2），我们可以得到等价公式：  
$$ g = w_0 * w_1 * (\mu_0 - \mu_1)^2 \tag(3) $$  
依次令阈值为0到255之间的所有的值，用公式（3）计算类间方差，保存使类间方差最大的阈值用作该图像二值化的阈值。

Kittler二值化
---
Kittler算法与Otsu方法效果接近，但速度更快，更适宜应用于像素质量较高的图像中。  
它的中心思想是，计算整幅图像的梯度灰度的平均值，以此平均值做为阈值。

二值化效果
---
![before]({{page.resource_path}}/before.png)
![after]({{page.resource_path}}/after.png)




