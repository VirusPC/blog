---
title: 二值化
categories: ['图像处理']
tags: [‘二值化’, 'binarize']
resource_path: /blog/assets/2020/06/05/binarize
---

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>

二值化
===

灰度图每个像素点的灰度都在0到255之间，二值化就是让每个像素点的值只能为0或255，使得图像呈现出明显的黑白对比效果。二值化进一步突出了图像的特征，缩减了图像的数据量，使得图像的进一步处理更为容易。二值化的一般思路是设置一个阈值，然后对图片的每个像素点进行判断：若灰度值大于阈值，则置灰度值为255；若灰度值小于阈值，则置灰度值为0。二值化方法有很多种：

* 全局阈值法
    * [实验法](#实验法])
    * [根据直方图谷底确定阈值](#根据直方图谷底确定阈值)
    * [迭代选择阈值法](#迭代选择阈值法)
    * [最小均方误差法](#最小均方误差法)
    * [最大熵法](#最大熵法)
    * [OSTU算法（大津算法、最大类间方法法）](#OSTU算法)
    * [Kittler算法](#Kittler算法)
* 局部阈值法
    * [bernsen算法](#bersen算法)
    * [niblack算法](#niblack算法)

---

实验法
---
通过人眼的观察，对已知某些特征的图像，只要实验不同的阈值，然后看是否满足已知特性即可。  
  
这种方法的问题是适用范围窄，使用前必须事先知道图像的某些特征，譬如平均灰度等，且分割后图像质量的好坏受主观局限性的影响很大。在实际应用中，由于两种情况的出现，我们很难以找到一个对所有图片通用的阈值：有可能图像前景和图像背景的灰度值都很大或图像前景和图像背景的灰度值都很小。  

根据直方图谷底确定阈值
---
如果图像的前景物体内部和背景区域的灰度值分布都比较均匀，那么这个图像的灰度直方图将具有明显的双峰，此时可以选择两峰之间的谷底作为阈值。  

此种单阈值分割方法简单易操作，但是当两个峰值相差很远时不适用，而且此种方法比较容易受噪声的影响，进而导致阈值选取的误差。  
对于有多个峰值的直方图，可以选取多个阈值，这些阈值的选取一般没有统一的规则，要根据实际情况运用。  

此外由于直方图是只是像素灰度值的统计，所以其峰值和谷底不一定代表前景和背景。因此，如果没有图像其他方面的知识，只靠直方图进行图像分割并不一定准确。  

迭代选择阈值法
---
迭代选择阈值选择方法的基本思想是：开始选择一个阈值作为初始估计值，然后按照某种规则不断地更新这一估计值，直到满足给定的条件为止。这个过程的关键是迭代规则的选择。一个好的迭代规则必须既能够快速收敛，又能够在每一个迭代过程中产生优于上次迭代的结果。  

步骤如下：  
    1. 选择一个T的初始估计值  
    2. 利用阈值T把图像分为两个区域$$ R_1 $$和$$ R_2 $$。  
    3. 对区域$$R_1$$和$$R_2$$中的所有像素计算平均灰度值$$ \mu_1 $$和$$ \mu_2 $$。  
    4. 计算新的阈值$$ T = \frac{1}{2}(\mu_1+\mu_2) $$  
    5. 重复步骤 2~4，直到逐次迭代所得到的T值小于事先定义的参数T  

最小均方误差法
---
最小均方误差法也是常用的阈值分割法之一。这种方法通常以图像中的灰度作为模式特征，假设各模式的灰度是独立分布的随机变量，并假设图像中待分割的模式符从一定的概率分布。一般来说，采用的是正态分布。  

最大熵法
---
在信息论中，信息熵可以说明消息的混沌程度，熵越大说明消息越不明了，难以从消息中得到有效信息。举一个超级简单的例子，假设一辆车开到了一个T字型的路口，限定它必须要么左转，要么右转，设左转的概率是P1，右转的概率是P2，除此之外没有任何信息了，问如何估计P1和P2？你现在有的信息仅仅是P1+P2=1而已，按最大熵的思想，既然你没有其他任何信息来说明向左转的可能性比向右转的可能性大（或小），那就应该把它们两一视同仁，同等对待，不能偏袒其一，于是应该 P1=P2=1/2，这就是最大熵的思想。  

最大熵法在论文*《A New Method forGray-Level Picture ThresholdingUsing the Entropy of the Histogram》*中被提出。它的思想是计算所有分割阈值下的图像总熵，找到最大的熵，将最大熵对应的分割阈值作为最终的阈值。

OSTU算法
---
OSTU算法也被称为大津法、最大类间方差法，它把图像所有的像素点按灰度值分成大于阈值和小于阈值两类，即分成前景和背景两个部分，然后计算两个类间的“类间方差”。类间方差越大，二值化效果就越好。  

记图像前景的像素点数量占全部像素点数量比例为$$ w_0 $$，前景的平均灰度为$$ \mu_0 $$；图像背景的像素点数量占全部像素点数量的比例为$$ w_1 $$，背景像素点的平均灰度值为$$ \mu_1 $$；所有像素点灰度值的平均值为$$ \mu $$，类间方差为g，我们可以得到如下的公式：  
$$
\mu = w_0 * \mu_0 + w_1 * \mu_1 \tag{1}
$$  
$$
g = w_0*(\mu_0-\mu)^2+w_1*(\mu_1-\mu)^2 \tag{2}
$$  
将公式（1）代入公式（2），我们可以得到等价公式：  
$$ g = w_0 * w_1 * (\mu_0 - \mu_1)^2 \tag{3} $$  
依次令阈值为0到255之间的所有的值，用公式（3）计算类间方差，保存使类间方差最大的阈值用作该图像二值化的阈值。

Kittler算法
---
Kittler算法与Otsu方法效果接近，但速度更快，更适宜应用于像素质量较高的图像中。  

它的中心思想是，计算整幅图像的梯度灰度的平均值，以此平均值做为阈值。

二值化效果
---
![before]({{page.resource_path}}/before.png)
![after]({{page.resource_path}}/after.png)




